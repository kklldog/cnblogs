在asp。net core之前所有的action返回值都是actionresult，Json(),file()等方法返回的都是actionresult的子类。并且core把mvc跟webapi合并之后action的返回值体系也有了很大的变化。
## ActionResult类
actionresult类是最常用的返回值类型。基本沿用了之前asp。net mvc的那套东西，使用它大部分情况都没问题。比如用它来返回视图，返回json，返回文件等等。如果是异步则使用Task<ActionResult>。
```
    public class TestController : Controller
    {
        public ActionResult Index()
        {
            return View();
        }

        public ActionResult MyFile()
        {
            return File(new byte[] { }, "image/jpg");
        }

        public ActionResult MyJson()
        {
            return Json(new { name = "json" });
        }

        public ActionResult Ok()
        {
            return Ok();
        }
    }
```
## IActionResult接口
ActionResult类实现了IActionResult接口所以能用ActionResult的地方都可以使用IActionResult来替换。同样异步的话使用Task包起来做为返回值。
```
   public class ITestController : Controller
    {
        public IActionResult Index()
        {
            return View();
        }

        public IActionResult MyFile()
        {
            return File(new byte[] { }, "image/jpg");
        }

        public IActionResult MyJson()
        {
            return Json(new { name = "json" });
        }

        public IActionResult HttpOk()
        {
            return Ok();
        }

        public async Task<IActionResult> AsyncCall()
        {
            await Task.Delay(1000);

            return Content("ok");
        }
    }
```
## 直接返回POCO类
asp.netcore的Controller的action可以把POCO类型(其实不一定是POCO类，可以是任意类型，但是使用的时候一般都返回viwemodel等POCO类)当做返回值，不一定非要是actionresult或者iactionresult。asp.netcore框架会帮我们自动序列化返回给前端，默认使用json序列化。同样异步的话使用Task包起来做为返回值。
```
   public class Person
    {
        public string Name { get; set; }

        public string Sex { get; set; }
    }

    public class ITestController : Controller
    {

          public Person GetPerson()
        {
            return new Person { Name = "abc", Sex = "f" };
        }

        public async Task<List<Person>> GetPersons()
        {
            await Task.Delay(1000);

            return new List<Person> {
            new Person { Name = "abc", Sex = "f" },
            new Person { Name = "efg", Sex = "m" }
            };
        }
    }
```
## ActionResult< T >泛型类
当我们设计restful webapi系统的时候习惯使用POCO做为返回值。比如我们设计一个获取Person的api。通过 /api/person/001 url获取001号person。
```
    [Route("[controller]")]
    public class PersonController : Controller
    {
        IPersonRepository _repository;
        PersonController(IPersonRepository repository) 
        {
            _repository = repository;
        }

        [HttpGet("{id}")]
       public Person Get(string id)
        {
            return _repository.Get(id);
        }
    }
```
这个方法看起来好像没什么问题，其实有个小问题。如果repository。get方法没有根据id查找到数据，那么将会返回null。如果null做为action的返回值，最后框架会转换为204的http status code。204表示No Content 。做为restful api，204的语义在这里会有问题，这里比较适合的status code是404 NOT FOUND 。那么我们来改一下：
```
        [HttpGet("{id}")]
       public Person Get(string id)
        {
            var person = _repository.Get(id);
            if (person == null)
            {
                Response.StatusCode = 404;
            }

            return person;
        }
```
现在如果查找不到person数据，则系统会返回404 Not Found 。但是这看起来显然不够优雅，因为ControllerBase内置了NotFoundResult NotFound() 方法。这有代码看起来更加清晰明了。
```
        [HttpGet("{id}")]
       public Person Get(string id)
        {
            var person = _repository.Get(id);
            if (person == null)
            {
                return NotFound();
            }
            return person;
        }
```
很不幸，这段代码VS会提示错误。因为返回值类型不一致。方法签名的返回值是Person，但是方法内部一会返回NotFoundResult，一会返回Person。解决这个问题就该ActionResult< T >出场了。我们继续改一下：
```
        [HttpGet("{id}")]
       public ActionResult<Person> Get(string id)
        {
            var person = _repository.Get(id);
            if (person == null)
            {
                return NotFound();
            }

            return person;
        }
```
现在VS已经不会报错了，运行一下也可以正常工作。但仔细想想也很奇怪，为什么返回值类型改成了ActionResult< Person >就不报错了呢？明明返回值类型跟方法签名还是不一致啊？