---
layout: default
title:  "ASP.NET Core Authentication and Authorization"
---
最近把一个core2.0的项目迁移到core3.1，项目启动的时候直接报错。
```
InvalidOperationException: Endpoint CoreAuthorization.Controllers.HomeController.Index (CoreAuthorization) contains authorization metadata, but a middleware was not found that supports authorization.
Configure your application startup by adding app.UseAuthorization() inside the call to Configure(..) in the application startup code. The call to app.UseAuthorization() must appear between app.UseRouting() and app.UseEndpoints(...).
Microsoft.AspNetCore.Routing.EndpointMiddleware.ThrowMissingAuthMiddlewareException(Endpoint endpoint)
```
看意思是缺少了一个authorization的中间件，这个项目在core2.0上是没问题的。    
startup是这样注册的：
```
public class Startup
    {
        public Startup(IConfiguration configuration)
        {
            Configuration = configuration;
        }

        public IConfiguration Configuration { get; }

        // This method gets called by the runtime. Use this method to add services to the container.
        public void ConfigureServices(IServiceCollection services)
        {
            services.AddAuthentication(CookieAuthenticationDefaults.AuthenticationScheme).AddCookie(options =>
            {
                options.LoginPath = "/account/Login";
            });
            
            services.AddControllersWithViews();
        }

        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
            if (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }
            else
            {
                app.UseExceptionHandler("/Home/Error");
                // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
                app.UseHsts();
            }
            //app.UseHttpsRedirection();
            app.UseStaticFiles();

            app.UseRouting();

            app.UseAuthentication();

            app.UseEndpoints(endpoints =>
            {
                endpoints.MapControllerRoute(
                    name: "default",
                    pattern: "{controller=Home}/{action=Index}/{id?}");
            });
        }
    }
```
查了文档后发现3.0的示例代码多了一个UseAuthorization，改成这样就可以了：
```
 app.UseRouting();
 app.UseAuthentication();
 app.UseAuthorization();

 app.UseEndpoints(endpoints =>
            {
                endpoints.MapControllerRoute(
                    name: "default",
                    pattern: "{controller=Home}/{action=Index}/{id?}");
            });
```
看来core3.1的认证跟授权又不太一样了，只能继续看文档学习了。

## UseAuthentication and UseAuthorization
先说一下Authentication跟Authorization的区别。这两个单词长的十分相似，而且还经常一起出现，很多时候都会搞混了。Authentication是认证，明确是你谁，确认是不是合法用户。常用的认证方式有用户名密码来认证。Authorization是授权，明确你是否有某个权限。当用户需要使用某个功能的时候，系统需要校验用户是否需要这个功能的权限。所以这两个单词是不同的概念，不同层次的东西。    
UseAuthorization asp.net core 2.0中是没有的。在3.0之后微软明确的把授权功能提取到了Authorization中间件里，所以我们需要在UseAuthentication之后再次UseAuthorization。否则，当你使用授权功能比如使用[Authorize]属性的时候系统就会报错。

## Authentication（认证）
认证的方案有很多，最常用的就是用户名密码认证，下面演示下基于用户名密码的认证。新建一个MVC项目，添加AccountController：
```
        [HttpPost]
        public async Task<IActionResult> Login(
            [FromForm]string userName, [FromForm]string password
           )
        {
            //validate username password
            ...
            var claims = new List<Claim>
                {
                  new Claim(ClaimTypes.Name, userName),
                  new Claim(ClaimTypes.Role, "老师")
                };

            var claimsIdentity = new ClaimsIdentity(
                claims, CookieAuthenticationDefaults.AuthenticationScheme);

            await HttpContext.SignInAsync(
                CookieAuthenticationDefaults.AuthenticationScheme,
                new ClaimsPrincipal(claimsIdentity));

            return Redirect("/");
        }
         public async Task<IActionResult> Logoff()
        {
            await HttpContext.SignOutAsync();

            return Redirect("Login");
        }

        public IActionResult AccessDenied()
        {
            return Content("AccessDenied");
        }

```
修改login.cshtml
```
@{
    ViewData["Title"] = "Login Page";
}

    <h1>
        Login Page
    </h1>

    <form method="post">
        <p>
            用户名: <input name="userName" value="administrator" />
        </p>
        <p>
            密码: <input name="password" value="123" />
        </p>
       
        <p>
            <button>登录</button>
        </p>
    </form>
```
从前台传入用户名密码后进行用户名密码校验（示例代码省略了密码校验）。如果合法，则把用户的基本信息存到一个claim list里，并且指定cookie-base的认证存储方案。最后调用SignInAsync把认证信息写到cookie中。根据cookie的特性，接来下所有的http请求都会携带cookie，所以系统可以对接来下用户发起的所有请求进行认证校验。Claim有很多翻译，个人觉得叫“声明”比较好。一单认证成功，用户的认证信息里就会携带一串Claim，其实就是用户的一些信息，你可以存任何你觉得跟用户相关的东西，比如用户名，角色等，当然是常用的信息，不常用的信息建议在需要的时候查库。调用HttpContext.SignOutAsync()方法清除用户登认证信息。    
这些信息我们可以方便的获取到。
```
@{
    ViewData["Title"] = "Home Page";
}

    <h2>
        CoreAuthorization
    </h2>

<p>
    @Context.User.FindFirst(System.Security.Claims.ClaimTypes.Name).Value
</p>
<p>
    角色:
    @foreach (var claims in Context.User.Claims.Where(c => c.Type == System.Security.Claims.ClaimTypes.Role))
    {
        <span> @claims.Value </span>
    }
</p>
<p>
    <a href="/Student/index">/Student/index</a>
</p>
<p>
    <a href="/Teacher/index">/Teacher/Index</a>
</p>
<p>
    <a href="/Teacher/Edit">/Student/Edit</a>
</p>

<p>
    <a href="/Account/Logoff">退出</a>
</p>
```
改一下home/Index页面的html，把这些claim信息展示出来。    
![](https://s1.ax1x.com/2020/04/01/G3c7uR.png)    
以上就是一个基于用户名密码以及cookie的认证方案。
## Authorization（授权）
有了认证我们还需要授权。刚才我们实现了用户名密码登录认证，但是系统还是没有任何管控，用户可以随意查库任意页面。现实中的系统玩玩都是某些页面可以随意查看，有些页面则需要认证授权后才可以访问。
### AuthorizeAttribute
当我们希望一个页面只有认证后才可以访问，我们可以在相应的Controller或者Action上打上AuthorizeAttribute这个属性。修改HomeController：
```
    [Authorize]
    public class HomeController : Controller
    {
        public IActionResult Index()
        {
            return View();
        }

    }
```
重新启动网站，如果没有登录，访问home/index的时候网站会跳转到/account/AccessDenied。如果登录后则可以正常访问。Authorize默认授权其实是把认证跟授权合为一体了，只要认证过，就认为有授权。